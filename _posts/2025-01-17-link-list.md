---
title:  "算法漫谈-链表"
date: 2025-01-17 21:30:44 +0800
categories: algorithm link-list 算法 链表
---
本文的讨论都是围绕于单链表，一起总结常见的问题及解法。
单链表定义以力扣为准。
```java
public class ListNode {
    int val;
    ListNode next;
    ListNode() {}
    ListNode(int val) { this.val = val; }
    ListNode(int val, ListNode next) { this.val = val; this.next = next; }
}
```
## 反转
最基础的反转链表有递归和迭代两种形式，这里介绍递归。

问题定义
```text
给定一个链表的头节点，反转链表后返回新的头节点
```


<script defer type="text/tikz">
\begin{tikzpicture}[
every node/.style={circle, draw, node font=\large\bfseries, line width=1.5pt, minimum size=12mm},
]
\draw (0,0) node (a) {1} (2,0) node (b) {2} (4,0) node (c) {3};
\path[->] (a) edge (b) (b) edge (c);

\draw (0,2) node (e) {3} (2,2) node (f) {2} (4,2) node (g) {1};
\path[->] (e) edge (f) (f) edge (g);
\end{tikzpicture}
</script>

```java
// https://leetcode.cn/problems/reverse-linked-list/submissions/575156185/
    public ListNode reverseList(ListNode head) {
        if (head == null) {
            return null;
        }
    
        return reverse(null, head);
    }
    
    public ListNode reverse(ListNode prev, ListNode head) {
        ListNode next = head.next;
    
        if (next == null) {
            head.next = prev;
            return head;
        }
    
        ListNode newHead = reverse(head, next);
        head.next = prev;
        return newHead;
    }
```
反转链表关键在于
+ 遍历时记录prev节点，当前节点指向前一节点即完成反转
+ 由于最后一个节点变成头节点，需要执行到最后才能取得

这里我们引入一个和反转不相干的问题，为后续解题做铺垫
```text
给定一个链表，删除链表的倒数第n个结点，并且返回链表的头结点。
```
举例，删除倒数第二个节点

<script defer type="text/tikz">
\begin{tikzpicture}[
every node/.style={circle, draw, node font=\large\bfseries, line width=1.5pt, minimum size=12mm},
bluenode/.style={fill=teal!20},
]
\draw (0,2) node (a) {1} (2,2) node[bluenode] (b) {2} (4,2) node (c) {3};
\path[->] (a) edge (b) (b) edge (c);

\draw (0,0) node (e) {1} (4,0) node (g) {3};
\path[->] (e) edge (g);

\end{tikzpicture}
</script>

我们可以采用`快慢指针`的方式，思路如下
+ 快慢指针都指向头节点
+ 先将快指针向前走n步
+ 快慢指针同步前进，直到快指针为空时，慢指针即指向倒数第n个节点

还是以图为例，假设要求倒数第二个节点

<script defer type="text/tikz">
\begin{tikzpicture}[
every node/.style={circle, draw, node font=\large\bfseries, line width=1.5pt, minimum size=12mm},
bluenode/.style={fill=teal!20},
greennode/.style={fill=green!20},
]
\draw (0,4) node[greennode] (a) {4} (2,4) node (b) {3} (4,4) node[bluenode] (c) {2} (6,4) node (d) {1} (8,4) node[draw=none] (e) {null};
\path[->] (a) edge (b) (b) edge (c) (c) edge (d) (d) edge (e);

\draw (0,2) node (f) {4} (2,2) node[greennode] (g) {3} (4,2) node (h) {2} (6,2) node[bluenode] (i) {1} (8,2) node[draw=none] (j) {null};
\path[->] (f) edge (g) (g) edge (h) (h) edge (i) (i) edge (j);

\draw (0,0) node (k) {4} (2,0) node (l) {3} (4,0) node[greennode] (m) {2} (6,0) node (n) {1} (8,0) node[draw=none] (o) {null};
\path[->] (k) edge (l) (l) edge (m) (m) edge (n) (n) edge (o);
\end{tikzpicture}
</script>

可以清楚地看到指针移动的轨迹<br>
上图解决了求倒数第n个节点的问题，要删除这个节点，就要求倒数第n+1个节点

```java
// https://leetcode.cn/problems/remove-nth-node-from-end-of-list/submissions/593841422/
    public ListNode removeNthFromEnd(ListNode head, int n) {
        int counter = 0;
        ListNode dummy = new ListNode(0, head);
        ListNode front = head, back = dummy;
        while (counter != n) {
            front = front.next;
            counter++;
        }
    
        while (front != null) {
            front = front.next;
            back = back.next;
        }
    
        back.next = back.next.next;
    
        return dummy.next;
    }
```
+ 快指针先走了n步，而慢指针后退了一步(从dummy节点出发)，所以最终走到倒数第n+1个节点
+ 新的头节点由dummy.next指向

## 环形

## 合并

## 拆分

## 排序

## LRU