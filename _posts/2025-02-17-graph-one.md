---
title:  "å›¾ç¬¬ä¸€è®²"
date: 2025-02-17 07:50:00 +0800
categories: algorithm graph ç®—æ³• å›¾è®º
---

å›¾è®ºæ˜¯è®¡ç®—æœºç§‘å­¦ä¸­éå¸¸é‡è¦ä¹Ÿéå¸¸æœ‰è¶£çš„ä¸€éƒ¨åˆ†ï¼Œåœ¨æ—¥å¸¸ç”Ÿæ´»ä¸­ä¹Ÿæœ‰å¹¿é˜”çš„åº”ç”¨åœºæ™¯ã€‚  
æœ¬ç« ä¸»è¦å…³æ³¨å›¾çš„æœç´¢ï¼Œé¦–å…ˆæ¥çœ‹å›¾çš„å®šä¹‰ã€‚  

## å®šä¹‰
å›¾æ˜¯ç”±è‹¥å¹²é¡¶ç‚¹Eå’Œè¿æ¥é¡¶ç‚¹çš„è¾¹Vç»„æˆï¼Œå®šä¹‰ä¸€å¼ å›¾ä¸€èˆ¬ä½¿ç”¨é‚»æ¥è¡¨æˆ–è€…é‚»æ¥çŸ©é˜µï¼Œæœ¬æ–‡ç»Ÿä¸€ä½¿ç”¨é‚»æ¥è¡¨ã€‚  
å¯¹äºè¾¹åªç”¨æ¥è¿æ¥ä¸¤ä¸ªå®šç‚¹ï¼Œæ²¡æœ‰æ˜ç¡®æ–¹å‘çš„ï¼Œç§°ä¸ºæ— å‘å›¾ï¼Œåç»­å›¾ä¸­é¡¶ç‚¹éƒ½ç”¨ç›´çº¿è¿æ¥ã€‚  
ç›¸å¯¹åº”è¾¹æœ‰æ–¹å‘çš„ï¼Œç§°ä¸ºæœ‰å‘å›¾ï¼Œå›¾ä¸­é¡¶ç‚¹ç”¨å¸¦æ–¹å‘çš„ç®­å¤´è¿æ¥ã€‚  
é¦–å…ˆçœ‹ä¸€ä¸ªæ— å‘å›¾åŠå…¶è¡¨ç¤ºã€‚

<script defer type="text/tikz">
\def\d{0pt}
\definecolor{airforceblue}{rgb}{0.36, 0.54, 0.66}
\definecolor{almond}{rgb}{0.94, 0.87, 0.8}
\definecolor{arylideyellow}{rgb}{0.91, 0.84, 0.42}
\definecolor{ashgrey}{rgb}{0.7, 0.75, 0.71}
\ifdim\d=0pt 
    \def\DrawFlag{}%
\else
    \def\DrawFlag{draw}%
\fi\begin{tikzpicture}[
every node/.style={minimum size=1cm, \DrawFlag, outer sep=0, inner sep=0, line width=\d, font=\large\bfseries},
circle node/.style={circle, draw, minimum size=1cm, line width=1pt, font=\large\bfseries},
]

\matrix (m) [nodes in empty cells,column sep=-\d, row sep=-\d,]
{
 & \node[circle node] (a) {0}; & \\
 &  &  \\
\node[circle node] (b) {1}; &  & \node[circle node] (c) {2}; \\
};


\draw (a) -- (b) (b) -- (c) (c) -- (a);
\end{tikzpicture}
</script>

å¯ä»¥çœ‹åˆ°æœ‰3ä¸ªé¡¶ç‚¹(0,1,2)å’Œä¸‰æ¡è¾¹ï¼Œé‚»æ¥è¡¨æ˜¯è¿™æ ·çš„ã€‚  

<script defer type="text/tikz">
\begin{tikzpicture}[
every node/.style={node font=\large\bfseries, line width=1.5pt, minimum size=12mm},
]

\node at (-1,0.5) {0};

\foreach \x/\v/\t in {0/1,1/2} {
  \pgfmathsetmacro{\next}{int(\x+1)};
  \draw (\x,0) rectangle node (a\x) {\v} (\next,1);
}

\node at (-1,-0.5) {1};

\foreach \x/\v/\t in {0/0,1/2} {
  \pgfmathsetmacro{\next}{int(\x+1)};
  \draw (\x,-1) rectangle node (b\x) {\v} (\next,0);
}

\node at (-1,-1.5) {2};

\foreach \x/\v/\t in {0/0,1/1} {
  \pgfmathsetmacro{\next}{int(\x+1)};
  \draw (\x,-2) rectangle node (b\x) {\v} (\next,-1);
}

\end{tikzpicture}
</script>

å¯ä»¥çœ‹åˆ°é‚»æ¥è¡¨æœ¬è´¨ä¸Šæ˜¯ä¸€ä¸ªäºŒç»´æ•°ç»„ï¼Œæˆ‘ä»¬ç”¨List<List<Integer>> adjTableè¡¨ç¤ºã€‚  
`adjTable.size()`å°±æ˜¯é¡¶ç‚¹ä¸ªæ•°ï¼Œ`adjTable.get(i)`å°±ä»£è¡¨å’Œé¡¶ç‚¹iç›¸é‚»çš„é¡¶ç‚¹åˆ—è¡¨ï¼Œ  
ç”±äºæ— å‘å›¾æ˜¯åŒå‘è¿æ¥çš„ï¼Œå¯ä»¥çœ‹åˆ°(0,1)å’Œ(1,0)éƒ½åœ¨è¡¨ä¸­ã€‚

## æ·±åº¦ä¼˜å…ˆæœç´¢
è¿™é‡Œæˆ‘ä»¬é»˜è®¤å¤§å®¶å¯¹æ·±åº¦ä¼˜å…ˆæœç´¢æœ‰ä¸€å®šäº†è§£ï¼Œæˆ‘ä»¬ç›´æ¥ä»é¢˜ç›®å…¥æ‰‹ã€‚

### å²›å±¿æ•°é‡
```text
ç»™å®šä¸€ä¸ªäºŒç»´çŸ©é˜µï¼ŒåªåŒ…å«'1'(é™†åœ°)å’Œ'0'(æ°´)ï¼Œè®¡ç®—æ‰€æœ‰çš„å²›å±¿æ•°é‡ã€‚
å²›å±¿è¢«æ°´åŒ…å›´ï¼Œå²›å±¿éƒ½ç”±æ°´å¹³å’Œå‚ç›´æ–¹å‘ä¸Šç›¸é‚»çš„é™†åœ°è¿æ¥è€Œæˆï¼ŒçŸ©é˜µå¤–çš„éƒ¨åˆ†éƒ½æ˜¯æ°´ã€‚
```

$$
\definecolor{airforceblue}{rgb}{0.36, 0.54, 0.66}
\definecolor{almond}{rgb}{0.94, 0.87, 0.8}
\definecolor{arylideyellow}{rgb}{0.91, 0.84, 0.42}
\definecolor{ashgrey}{rgb}{0.7, 0.75, 0.71}
\begin{array}{|c|c|c|c|c|}
\hline
\cellcolor{almond}1 & \cellcolor{almond}1 & 0 & 0 & 0 \\
\hline
\cellcolor{almond}1 & \cellcolor{almond}1 & 0 & 0 & 0 \\
\hline
0 & 0 & \cellcolor{almond}1 & 0 & 0 \\
\hline
0 & 0 & 0 & \cellcolor{almond}1 & \cellcolor{almond}1 \\
\hline
\end{array}
$$

ä¸Šå›¾ä¸­å°±æœ‰3ä¸ªå²›å±¿ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸‰ç§æ–¹å¼æ¥æ±‚è§£
1. æ·±åº¦éå†ï¼Œæ¯æ¬¡æœç´¢ä¸Šä¸‹å·¦å³å››ä¸ªæ–¹å‘çš„æœªéå†åˆ°çš„èŠ‚ç‚¹ï¼Œå•æ¬¡éå†åˆ°çš„èŠ‚ç‚¹å±äºä¸€ä¸ªå²›å±¿
2. å¹¿åº¦éå†ï¼Œå’Œæ·±åº¦éå†ç±»ä¼¼ï¼Œåªæ˜¯æ¯æ¬¡åŒæ—¶å‘å››ä¸ªæ–¹å‘æ‰©å±•
3. å¹¶æŸ¥é›†ï¼Œæ¯ä¸ªè¿é€šåˆ†é‡å°±æ˜¯ä¸€ä¸ªå²›å±¿

æˆ‘ä»¬å±•ç¤ºæ–¹æ³•ä¸€å’Œä¸‰çš„ä»£ç 

```java
// https://leetcode.cn/problems/number-of-islands/submissions/612053722
    char[][] grid;
    boolean[][] visited;
    public int numIslands(char[][] grid) {
        boolean[][] visited = new boolean[grid.length][grid[0].length];
        int count = 0;
        this.grid = grid;
        this.visited = visited;

        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                if (grid[i][j] == '1' && !visited[i][j]) {
                    count++;
                    search(i, j);
                }
            }
        }
        return count;
    }

    private void search(int i, int j) {
        if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length) {
            return;
        }
        if (visited[i][j] || grid[i][j] == '0') {
            return;
        }
        visited[i][j] = true;
        search(i + 1, j);
        search(i - 1, j);
        search(i, j + 1);
        search(i, j - 1);
    }
```
æ³¨æ„å¯¹åæ ‡å’Œæ˜¯å¦å·²è®¿é—®çš„æ£€æŸ¥æ˜¯åœ¨è¿›å…¥æ— æ•ˆåæ ‡ä¹‹åè¿›è¡Œçš„ï¼Œä¹Ÿå¯ä»¥åœ¨è°ƒç”¨searchä¹‹å‰æ£€æŸ¥ã€‚

```java
// https://leetcode.cn/problems/number-of-islands/submissions/612072522
    private static class UnionFind {
        int[] parent, size;
        public UnionFind(char[][] grid) {
            int m = grid.length, n = grid[0].length;
            parent = new int[m * n];
            size = new int[m * n];
            for (int i = 0; i < parent.length; i++) {
                parent[i] = i;
                size[i] = grid[i / n][i % n] == '1' ? 1 : 0;
            }
        }

        public int find(int i) {
            while (parent[i] != i) {
                i = parent[i];
            }
            return i;
        }

        public void union(int i, int j) {
            int parentI = find(i), parentJ = find(j);
            if (parentI == parentJ) {
                return;
            }
            if (size[parentI] < size[parentJ]) {
                size[parentJ] += size[parentI];
                size[parentI] = 0;
                parent[parentI] = parentJ;
            } else {
                size[parentI] += size[parentJ];
                size[parentJ] = 0;
                parent[parentJ] = parentI;
            }
        }

        public int parts() {
            int result = 0;
            for (int i = 0; i < size.length; i++) {
                if (size[i] != 0) {
                    result++;
                }
            }

            return result;
        }
    }

    private static final int[][] DIR = new int[][]{ {1, 0}, {0, 1}, {-1, 0}, {0, -1}};
    public int numIslands(char[][] grid) {
        int m = grid.length, n = grid[0].length;
        UnionFind unionFind = new UnionFind(grid);
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == '1') {
                    for (int k = 0; k < DIR.length; k++) {
                        int nextI = i + DIR[k][0], nextJ = j + DIR[k][1];
                        if (0 <= nextI && nextI < m && 0 <= nextJ && nextJ < n && grid[nextI][nextJ] == '1') {
                            unionFind.union(i * n + j, nextI * n + nextJ);
                        }
                    }
                }
            }
        }

        return unionFind.parts();
    }
```
æ³¨æ„å¹¶æŸ¥é›†ä¸­åªæœ‰ä¸ºé™†åœ°çš„èŠ‚ç‚¹sizeè®¾ä¸ºäº†1ã€‚

### å…‹éš†å›¾
<div class="language-text highlighter-rouge">
<pre class="highlight">
<code>
ç»™å®šæŸæ— å‘è¿é€šå›¾çš„ä¸€ä¸ªèŠ‚ç‚¹ï¼Œè¿”å›è¯¥å›¾çš„ æ·±æ‹·è´ã€‚
èŠ‚ç‚¹ç”±å€¼å’Œé‚»å±…åˆ—è¡¨ç»„æˆ
class Node {
    public int val;
    public List&lt;Node&gt; neighbors;
}
</code>
</pre>
</div>

æˆ‘ä»¬å¯ä»¥ç”¨æ·±åº¦æœç´¢ï¼Œè¾¹éå†èŠ‚ç‚¹ï¼Œè¾¹åˆ›å»ºæ–°èŠ‚ç‚¹ï¼Œç”¨Mapè®°å½•è€èŠ‚ç‚¹å’Œæ–°èŠ‚ç‚¹çš„æ˜ å°„ã€‚  
å…³é”®é—®é¢˜åœ¨äºï¼Œæ€ä¹ˆæ·»åŠ é‚»å±…ï¼Œå¯ä»¥ä¸é‡å¤ã€‚  
æ·±åº¦éå†æ—¶ï¼Œæ¯å¯¹ç›¸é‚»çš„èŠ‚ç‚¹ä¼šé‡åˆ°ä¸¤æ¬¡ï¼Œå‡è®¾æœ‰aå’Œbä¸¤ä¸ªèŠ‚ç‚¹ï¼Œ  
ç¬¬ä¸€æ¬¡æ˜¯aéå†åˆ°æœªè®¿é—®çš„bï¼Œç¬¬äºŒæ¬¡æ˜¯béå†åˆ°å·²è®¿é—®çš„aï¼Œå¦‚æœæ¯æ¬¡éƒ½æ·»åŠ é‚»å±…è‚¯å®šä¼šé‡å¤ã€‚  
æ‰€ä»¥æˆ‘ä»¬åªåœ¨åºå·å°çš„èŠ‚ç‚¹è®¿é—®åˆ°åºå·å¤§çš„èŠ‚ç‚¹æ—¶æ·»åŠ é‚»å±…ã€‚

```java
// https://leetcode.cn/problems/clone-graph/submissions/612209043
    public Node cloneGraph(Node node) {
        if (node == null) {
            return null;
        }
        Map<Node, Node> oldToNew = new HashMap<>();
        dfs(node, oldToNew);
        return oldToNew.get(node);
    }

    private void dfs(Node node, Map<Node, Node> oldToNew) {
        if (oldToNew.containsKey(node)) {
            return;
        }
        Node newNode = new Node(node.val);
        oldToNew.put(node, newNode);
        for (Node neighbor : node.neighbors) {
            if (!oldToNew.containsKey(neighbor)) {
                dfs(neighbor, oldToNew);
            }
            Node newNeighbor = oldToNew.get(neighbor);
            if (node.val < neighbor.val) {
                newNode.neighbors.add(newNeighbor);
                newNeighbor.neighbors.add(newNode);
            }
        }
    }
```
åŒç†ä½¿ç”¨å¹¿åº¦æœç´¢ä¹Ÿå¯ä»¥è¾¾åˆ°åŒæ ·çš„æ•ˆæœã€‚

### é™¤æ³•æ±‚å€¼
```text
ç»™å®šä¸€ä¸ªå˜é‡å¯¹æ•°ç»„ equations å’Œä¸€ä¸ªå®æ•°å€¼æ•°ç»„ valuesï¼Œ
å…¶ä¸­equations[i] = [A,B] è¡¨ç¤º A / B = values[i]ï¼ŒAå’ŒBæ˜¯è¡¨ç¤ºä¸€ä¸ªå˜é‡çš„å­—ç¬¦ä¸²ã€‚
å¦æœ‰æ•°ç»„queriesä½œä¸ºé—®é¢˜ï¼Œqueries[j] = [C,D]è¡¨ç¤ºéœ€è¦æ±‚ C / Dçš„å€¼ï¼ŒCå’ŒDä¹Ÿæ˜¯è¡¨ç¤ºå˜é‡çš„å­—ç¬¦ä¸²ã€‚  
å¦‚æœç­”æ¡ˆæ— æ³•æ±‚è§£ï¼Œè¿”å›-1.0ï¼Œå¦‚æœæœ‰ä¸å­˜åœ¨çš„å˜é‡ï¼Œä¹Ÿè¿”å›-1.0ã€‚

è¾“å…¥ï¼šequations = [["a","b"],["b","c"]], values = [2.0,3.0], queries = [["a","c"],["b","a"],["a","e"]]
è¾“å‡ºï¼š[6.0,0.5,-1.0] (a / c = (a / b) * (b / c) = 6, b / a = 1 / (a / b) = 0.5, eæœªå®šä¹‰æ‰€ä»¥è¿”å›-1)
```

æœ¬é¢˜æœ¬è´¨ä¸Šæ˜¯ä¸€ä¸ªæ— å‘å›¾ä¸­è¿é€šåˆ†é‡çš„é—®é¢˜ï¼Œæ¯ä¸ªå˜é‡éƒ½æ˜¯ä¸€ä¸ªèŠ‚ç‚¹ï¼Œæ¯ä¸ªç­‰å¼æ˜¯ä¸€æ¡è¾¹ï¼ŒåŒä¸€è¿é€šåˆ†é‡ä¸­çš„èŠ‚ç‚¹å¯ä»¥ç›¸é™¤ã€‚  
è¿é€šåˆ†é‡é—®é¢˜é€‚åˆç”¨å¹¶æŸ¥é›†å¤„ç†ï¼Œæ¯ä¸ªèŠ‚ç‚¹é¢å¤–å­˜å‚¨ä¸€ä¸ªå€¼ï¼Œè¡¨ç¤ºfindæ‰¾åˆ°çš„ç‚¹å’Œè‡ªèº«ç›¸é™¤çš„ç»“æœï¼Œ  
å‡è®¾`find(b)=a,find(c)=a`ï¼Œ`b / c = a / c / (a / b)`ã€‚

```java
// https://leetcode.cn/problems/evaluate-division/submissions/544066889
    private static class UnionFind {
        private int[] id, weight;
        private double[] value;

        public UnionFind(int len) {
            id = new int[len];
            weight = new int[len];
            value = new double[len];

            for (int i = 0; i < len; i++) {
                id[i] = i;
                weight[i] = 1;
                value[i] = 1;
            }
        }

        public int find(int i) {
            while (id[i] != i) {
                i = id[i];
            }
            return i;
        }

        public void union(int a, int b, double value) {
            int groupA = find(a), groupB = find(b);
            if (groupA == groupB) {
                return;
            }
            int weightA = weight[groupA], weightB = weight[groupB];
            if (weightA > weightB) {
                id[groupB] = groupA;
                weight[groupA] += weight[groupB];
                this.value[groupB] = getValue(a) / getValue(b) * value;
            } else {
                id[groupA] = groupB;
                weight[groupB] += weight[groupA];
                this.value[groupA] = getValue(b) / getValue(a) / value;
            }
        }

        public double getValue(int i) {
            double result = 1;
            while (id[i] != i) {
                result *= value[i];
                i = id[i];
            }
            return result;
        }
    }

    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {
        Map<String, Integer> varToIdx = new HashMap<>();
        int idx = 0;
        for (List<String> equation : equations) {
            if (!varToIdx.containsKey(equation.get(0))) {
                varToIdx.put(equation.get(0), idx++);
            }
            if (!varToIdx.containsKey(equation.get(1))) {
                varToIdx.put(equation.get(1), idx++);
            }
        }

        int varCount = varToIdx.size();
        UnionFind uf = new UnionFind(varCount);
        for (int i = 0; i < equations.size(); i++) {
            List<String> equation = equations.get(i);
            uf.union(varToIdx.get(equation.get(0)), varToIdx.get(equation.get(1)), values[i]);
        }

        double[] result = new double[queries.size()];
        for (int i = 0; i < queries.size(); i++) {
            List<String> querie = queries.get(i);
            if (!varToIdx.containsKey(querie.get(0)) || !varToIdx.containsKey(querie.get(1))) {
                result[i] = -1;
                continue;
            }

            int idx1 = varToIdx.get(querie.get(0)), idx2 = varToIdx.get(querie.get(1));
            int group1 = uf.find(idx1), group2 = uf.find(idx2);
            if (group1 != group2) {
                result[i] = -1;
            } else {
                result[i] = uf.getValue(idx2) / uf.getValue(idx1);
            }
            
        }

        return result;
    } 
```
`varToIdx`å­˜å‚¨å˜é‡ååˆ°èŠ‚ç‚¹åºå·çš„æ˜ å°„ï¼Œæ±‚è§£èŠ‚ç‚¹æœªå®šä¹‰æˆ–ä¸åœ¨ä¸€ä¸ªè¿é€šåˆ†é‡å†…ï¼Œåˆ™è¿”å›-1ï¼Œ  
åœ¨åŒä¸€ä¸ªè¿é€šåˆ†é‡å†…ï¼Œåˆ™å¯¹èŠ‚ç‚¹åˆ†åˆ«æ±‚å€¼å¹¶ç›¸é™¤ã€‚  
å½“ç„¶ç”¨æ·±åº¦æœç´¢ä¹Ÿæ˜¯å¯ä»¥çš„ï¼Œæ‰¾åˆ°ä¸¤ç‚¹é—´çš„è·¯å¾„å°±èƒ½æ±‚å®ƒä»¬ç›¸é™¤çš„å€¼ï¼Œé¢˜ç›®ä¿è¯è·¯å¾„å”¯ä¸€ã€‚

## å¹¿åº¦ä¼˜å…ˆæœç´¢
ä»¥ä¸‹å†…å®¹é»˜è®¤å¤§å®¶äº†è§£å¹¿åº¦ä¼˜å…ˆæœç´¢çš„åŸºæœ¬åŸç†å’Œä½¿ç”¨ã€‚

### è…çƒ‚çš„æ©˜å­
```text
ç»™å®šm x nç½‘æ ¼gridï¼Œæ¯ä¸ªå•å…ƒæ ¼æœ‰ä»¥ä¸‹ä¸‰ä¸ªå€¼ä¹‹ä¸€ï¼š
Â· 0ä»£è¡¨ç©ºç™½æ ¼
Â· 1ä»£è¡¨æ–°é²œæ©˜å­
Â· 2ä»£è¡¨è…çƒ‚çš„æ©˜å­
æ¯åˆ†é’Ÿï¼Œè…çƒ‚çš„æ©˜å­ä¼šä¼ æŸ“å‘¨å›´å››ä¸ªæ–¹å‘çš„ç›¸é‚»æ©˜å­ï¼Œä½¿å…¶è…çƒ‚ã€‚
æ±‚æ‰€æœ‰æ©˜å­è…çƒ‚çš„æœ€å°åˆ†é’Ÿæ•°ï¼Œå¦‚æœä¸ä¼šéƒ½è…çƒ‚ï¼Œè¿”å›-1ã€‚
```

$$
\definecolor{airforceblue}{rgb}{0.36, 0.54, 0.66}
\definecolor{almond}{rgb}{0.94, 0.87, 0.8}
\definecolor{arylideyellow}{rgb}{0.91, 0.84, 0.42}
\definecolor{ashgrey}{rgb}{0.7, 0.75, 0.71}
\begin{array}{c}
minute 0 \\
\begin{array}{|c|c|}
\hline
ğŸŠ_0 & ğŸŠ_0 \\
\hline
 & ğŸŠ \\
\hline
\end{array}
\end{array}
\;\;\;
\begin{array}{c}
minute 1 \\
\begin{array}{|c|c|}
\hline
ğŸŠ_0 & ğŸŠ_0 \\
\hline
& ğŸŠ_0 \\
\hline
\end{array}
\end{array}
$$

å¦‚ä¸Šå›¾ï¼Œä½¿ç”¨ğŸŠè¡¨ç¤ºæ–°é²œæ©˜å­ï¼Œå¸¦ä¸‹æ ‡içš„æ©˜å­è¡¨ç¤ºåœ¨ç¬¬iåˆ†é’Ÿè…çƒ‚çš„æ©˜å­ã€‚  
ä¸Šå›¾ä¸­æ‰€æœ‰æ©˜å­åœ¨ç¬¬ä¸€åˆ†é’Ÿå°±éƒ½è…çƒ‚äº†ï¼Œæ‰€ä»¥è¿”å›1ã€‚  
æœ¬é¢˜å¯ä»¥é€šè¿‡å¹¿åº¦ä¼˜å…ˆæœç´¢æ¥å¤„ç†ï¼Œåœ¨æ¯ä¸ªå•å…ƒæ ¼è®°å½•æ©˜å­è…çƒ‚çš„æœ€å°åˆ†é’Ÿï¼Œå€¼ä¸ºæœ€å°åˆ†é’Ÿæ•°åŠ äºŒï¼Œä»¥å…¼å®¹0ã€1ã€2ä¸‰ä¸ªå€¼ã€‚  
ä»¥æ¯ä¸ªå¼€å§‹å°±è…çƒ‚çš„æ©˜å­aä¸ºèµ·ç‚¹ä½œå¹¿åº¦æœç´¢ï¼Œå°†å‘¨å›´æ©˜å­bçš„è…çƒ‚æ—¶é—´æ›´æ–°ä¸º$$min(time(a)+1,time(b))$$ã€‚  
å¦‚æœå°†æ•´ä¸ªç½‘æ ¼çš„å¼€å§‹å°±è…çƒ‚çš„æ©˜å­ä½œä¸ºèµ·ç‚¹éƒ½æœç´¢å®Œï¼Œå¦‚æœä»æœ‰æ–°é²œæ©˜å­ï¼Œè¿”å›-1ï¼Œå¦åˆ™è¿”å›æ‰¾åˆ°çš„æœ€å¤§å€¼-2ã€‚

$$
\definecolor{airforceblue}{rgb}{0.36, 0.54, 0.66}
\definecolor{almond}{rgb}{0.94, 0.87, 0.8}
\definecolor{arylideyellow}{rgb}{0.91, 0.84, 0.42}
\definecolor{ashgrey}{rgb}{0.7, 0.75, 0.71}
\begin{array}{c}
init \\
\begin{array}{|c|c|c|}
\hline
ğŸŠ_0 & ğŸŠ & ğŸŠ \\
\hline
ğŸŠ_0 &  &  \\
\hline
& ğŸŠ & ğŸŠ_0\\
\hline
\end{array}
\end{array}
\;\;\;
\begin{array}{c}
bfs(0,0) \\
\begin{array}{|c|c|c|}
\hline
\cellcolor{arylideyellow}ğŸŠ_0 & ğŸŠ_1 & ğŸŠ_2 \\
\hline
ğŸŠ_0 &  &  \\
\hline
& ğŸŠ & ğŸŠ_0\\
\hline
\end{array}
\end{array}
\;\;\;
\begin{array}{c}
bfs(1,0) \\
\begin{array}{|c|c|c|}
\hline
ğŸŠ_0 & ğŸŠ_1 & ğŸŠ_2 \\
\hline
\cellcolor{arylideyellow}ğŸŠ_0 &  &  \\
\hline
& ğŸŠ & ğŸŠ_0\\
\hline
\end{array}
\end{array}
\;\;\;
\begin{array}{c}
bfs(2,2) \\
\begin{array}{|c|c|c|}
\hline
ğŸŠ_0 & ğŸŠ_1 & ğŸŠ_2 \\
\hline
ğŸŠ_0 &  &  \\
\hline
& ğŸŠ_1 & \cellcolor{arylideyellow}ğŸŠ_0\\
\hline
\end{array}
\end{array}
\;\;\;
$$

å¦‚ä¸Šå›¾ï¼Œæ‰§è¡Œä¸‰è½®å¹¿åº¦æœç´¢ï¼Œç›´åˆ°ä»¥å³ä¸‹è§’çš„è…çƒ‚æ©˜å­ä¸ºèµ·ç‚¹æœç´¢å®Œï¼Œå¾—åˆ°å…¨éƒ¨è…çƒ‚çš„æœ€å°æ—¶é—´ä¸º2ã€‚

```java
    private static final int[][] DIR = new int[][]{ {1, 0}, {-1, 0}, {0, 1}, {0, -1}};
    public int orangesRotting(int[][] grid) {
        int m = grid.length, n = grid[0].length;
        boolean[][] visited = new boolean[m][n];

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 2) {
                    bfs(i, j, visited, grid);
                    clear(visited);
                }
            }
        }

        int max = 2;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) {
                    return -1;
                }
                max = Math.max(max, grid[i][j]);
            }
        }
        return max - 2;
    }

    private void bfs(int i, int j, boolean[][] visited, int[][] grid) {
        int m = grid.length, n = grid[0].length;
        Deque<int[]> queue = new ArrayDeque<>();
        visited[i][j] = true;
        queue.addLast(new int[]{i, j});

        while (!queue.isEmpty()) {
            int size = queue.size();
            for (int k = 0; k < size; k++) {
                int[] pair = queue.pollFirst();
                int row = pair[0], col = pair[1];
                for (int l = 0; l < DIR.length; l++) {
                    int nextI = row + DIR[l][0], nextJ = col + DIR[l][1];
                    if (isValid(nextI, nextJ, m, n) && grid[nextI][nextJ] != 0 && !visited[nextI][nextJ]) {
                        queue.addLast(new int[]{nextI, nextJ});
                        visited[nextI][nextJ] = true;
                        if (grid[nextI][nextJ] == 1) {
                            grid[nextI][nextJ] = 1 + grid[row][col];
                        } else {
                            grid[nextI][nextJ] = Math.min(grid[nextI][nextJ], 1 + grid[row][col]);
                        }
                    }
                }
            }
        }
    }

    private void clear(boolean[][] visited) {
        for (int i = 0; i < visited.length; i++) {
            for (int j = 0; j < visited[0].length; j++) {
                visited[i][j] = false;
            }
        }
    }

    private boolean isValid(int i, int j, int m, int n) {
        return 0 <= i && i < m && 0 <= j && j < n;
    }
```

### å•è¯æ¥é¾™
```text
åœ¨å­—å…¸ï¼ˆå•è¯åˆ—è¡¨ï¼‰ wordList ä¸­ï¼Œä»å•è¯ beginWord å’Œ endWord çš„ è½¬æ¢åºåˆ— æ˜¯ä¸€ä¸ªæŒ‰ä¸‹è¿°è§„æ ¼å½¢æˆçš„åºåˆ—ï¼š
Â· åºåˆ—ä¸­ç¬¬ä¸€ä¸ªå•è¯æ˜¯ beginWord ã€‚
Â· åºåˆ—ä¸­æœ€åä¸€ä¸ªå•è¯æ˜¯ endWord ã€‚
Â· æ¯æ¬¡è½¬æ¢åªèƒ½æ”¹å˜ä¸€ä¸ªå­—æ¯ã€‚
Â· è½¬æ¢è¿‡ç¨‹ä¸­çš„ä¸­é—´å•è¯å¿…é¡»æ˜¯å­—å…¸ wordList ä¸­çš„å•è¯ã€‚
ç»™å®šä¸¤ä¸ªé•¿åº¦ç›¸åŒä½†å†…å®¹ä¸åŒçš„å•è¯ beginWord å’Œ endWord å’Œä¸€ä¸ªå­—å…¸ wordList ï¼Œæ‰¾åˆ°ä» beginWord åˆ° endWord çš„ æœ€çŸ­è½¬æ¢åºåˆ— ä¸­çš„ å•è¯æ•°ç›® ã€‚
å¦‚æœä¸å­˜åœ¨è¿™æ ·çš„è½¬æ¢åºåˆ—ï¼Œè¿”å› 0ã€‚

è¾“å…¥ï¼šbeginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]
è¾“å‡ºï¼š5 (ä¸€ä¸ªæœ€çŸ­è½¬æ¢åºåˆ—æ˜¯ "hit" -> "hot" -> "dot" -> "dog" -> "cog", è¿”å›å®ƒçš„é•¿åº¦ 5ã€‚)
```

æŠŠæ¯ä¸ªå•è¯è§†ä¸ºä¸€ä¸ªç‚¹ï¼Œé—®é¢˜å°±è½¬æ¢ä¸º beginWord åˆ° endWordçš„æœ€çŸ­è·¯å¾„é—®é¢˜ï¼Œæ¯ä¸ªç‚¹é—´å¦‚æœæœ‰è·¯å¾„çš„è¯é•¿åº¦ä¸º1ï¼Œç­”æ¡ˆä¸ºé•¿åº¦+1ã€‚  
é—®é¢˜åœ¨äºæ€ä¹ˆæ‰¾å‡ºå¯ç›¸äº’è½¬æ¢çš„å•è¯ï¼Œä¸€èˆ¬æ–¹æ³•æ˜¯ä¸¤ä¸¤æ¯”è¾ƒï¼Œå¦‚æœä¸åŒå­—æ¯åªæœ‰ä¸€ä¸ªï¼Œåˆ™å¯ç›¸äº’è½¬æ¢ï¼Œå¤æ‚åº¦ä¸º$$O(mn^2)$$ï¼Œmä¸ºå•è¯é•¿åº¦ï¼Œnä¸ºå­—å…¸å¤§å°ã€‚  
è¿˜æœ‰ä¸€ç§æ›´é«˜æ•ˆçš„æ–¹å¼ï¼ŒæŠŠæ¯ä¸ªå•è¯æ‰©å±•æˆmä¸ªé€šé…ç¬¦ï¼Œä»¥"hit"ä¸ºä¾‹ï¼Œæ‰©å±•æˆ["&#42;it","h&#42;t","hi&#42;"]ä¸‰ä¸ªå•è¯ï¼Œæ˜¾ç„¶"hit"å’Œè¿™ä¸‰ä¸ªå•è¯éƒ½æ˜¯äº’ç›¸è¿æ¥çš„(&#42;è¡¨ç¤ºä»»æ„å•ä¸ªå­—ç¬¦)ã€‚  
è¿™æ ·ä¸¤ä¸ªå¯è½¬æ¢çš„å•è¯å°±é€šè¿‡é€šé…ç¬¦ç›¸äº’è¿æ¥äº†ï¼Œä»¥"hit"å’Œ"hot"ä¸ºä¾‹ï¼Œå¦‚ä¸‹å›¾ï¼Œä¸¤ä¸ªèŠ‚ç‚¹é€šè¿‡"h&#42;t"ç›¸è¿ã€‚  

<script defer type="text/tikz">
\def\d{0pt}
\definecolor{airforceblue}{rgb}{0.36, 0.54, 0.66}
\definecolor{almond}{rgb}{0.94, 0.87, 0.8}
\definecolor{arylideyellow}{rgb}{0.91, 0.84, 0.42}
\definecolor{ashgrey}{rgb}{0.7, 0.75, 0.71}
\ifdim\d=0pt 
    \def\DrawFlag{}%
\else
    \def\DrawFlag{draw}%
\fi\begin{tikzpicture}[
every node/.style={minimum size=1cm, \DrawFlag, outer sep=0, inner sep=0, line width=\d, font=\large\bfseries},
circle node/.style={circle, draw, minimum size=1cm, line width=1pt, font=\large\bfseries},
]

\matrix (m) [nodes in empty cells,column sep=5pt, row sep=20pt,]
{
 & \node[circle node] (a) {hit}; & \\
\node[circle node] (b) {$h\ast t$}; & \node[circle node] (d) {$\ast it$}; & \node[circle node] (e) {$hi\ast$}; \\
\node[circle node] (c) {hot}; &   & \\
};


\draw (a) -- (b) (b) -- (c) (a) -- (d) (a) -- (e);
\end{tikzpicture}
</script>

è¿™æ ·æ„é€ è·¯å¾„æ€»çš„èŠ‚ç‚¹æ•°è†¨èƒ€ä¸º$$(m+1)n$$ï¼Œæœ€å·®çš„æƒ…å†µä¸‹ï¼Œæ¯ä¸¤ä¸ªéé€šé…ç¬¦èŠ‚ç‚¹éƒ½ç›¸è¿ï¼Œæ¯æ¡è¾¹éƒ½ä¼šæ„é€ ä¸€æ¬¡ï¼Œè¿™æ ·å¤æ‚åº¦ä¸º$$O((m+1)n+n^2)$$ï¼Œå³ä¸¤è€…çš„æœ€å¤§å€¼ï¼Œ  
è€Œæœ€å¥½çš„æƒ…å†µä¸‹ï¼Œæ²¡æœ‰èŠ‚ç‚¹äº’è¿ï¼Œåˆ™å¤æ‚åº¦ä¸º$$O((m+1)n)$$ã€‚  
éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œè·¯å¾„ä¸Šçš„é€šé…ç¬¦èŠ‚ç‚¹ä¸è®¡ç®—åœ¨ç»“æœé‡Œã€‚

```java
// https://leetcode.cn/problems/word-ladder/submissions/540361326
    public int ladderLength(String beginWord, String endWord, List<String> wordList) {
        int endWordIdx = -1;
        int len = beginWord.length();
        for (int i = 0; i < wordList.size(); i++) {
            if (endWord.equals(wordList.get(i))) {
                endWordIdx = i;
                break;
            }
        }

        if (-1 == endWordIdx) {
            return 0;
        }

        int idx = 0;
        Map<String, Integer> wordToIdx = new HashMap<>();
        Map<Integer, String> idxToWord = new HashMap<>();
        List<List<Integer>> edges = new ArrayList<>();
        for (int i = 0; i <= wordList.size(); i++) {
            String word = i == 0 ? beginWord : wordList.get(i - 1);
            if (!wordToIdx.containsKey(word)) {
                wordToIdx.put(word, idx);
                idxToWord.put(idx++, word);
                edges.add(new ArrayList<>());
            }
            int wordIdx = wordToIdx.get(word);
            for (int j = 0; j < len; j++) {
                String wildcard = word.substring(0, j) + '*' + word.substring(j + 1);
                if (!wordToIdx.containsKey(wildcard)) {
                    wordToIdx.put(wildcard, idx);
                    idxToWord.put(idx++, wildcard);
                    edges.add(new ArrayList<>());
                }
                int wildcardIdx = wordToIdx.get(wildcard);
                edges.get(wordIdx).add(wildcardIdx);
                edges.get(wildcardIdx).add(wordIdx);
            }
        }

        boolean[] visited = new boolean[wordToIdx.size()];
        return bfs(0, wordToIdx.get(endWord), edges, visited, wordToIdx, idxToWord);
    }

    private int bfs(int from, int to, List<List<Integer>> edges, boolean[] visited, Map<String, Integer> wordToIdx, Map<Integer, String> idxToWord) {
        int[] parent = new int[visited.length];
        Deque<Integer> queue = new ArrayDeque<>();
        queue.addLast(from);
        visited[from] = true;
        parent[from] = -1;

        while (!queue.isEmpty()) {
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                int current = queue.pollFirst();
                if (current == to) {
                    int count = 1;
                    int parentIdx = parent[current];
                    while (parentIdx != -1) {
                        boolean isWildcard = idxToWord.get(parentIdx).contains("*");
                        count += isWildcard ? 0 : 1;
                        parentIdx = parent[parentIdx];
                    }
                    return count;
                }
                for (int next : edges.get(current)) {
                    if (!visited[next]) {
                        queue.addLast(next);
                        visited[next] = true;
                        parent[next] = current;
                    }
                }
            }
        }

        return 0;
    }
```

